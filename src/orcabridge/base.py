from orcabridge.hashing import HashableMixin
from .types import Tag, Packet
from typing import (
    Optional,
    Tuple,
    List,
    Any,
    Collection,
    Callable,
    Iterator,
)
from collections.abc import Collection
from typing import Any, List, Tuple


class Operation(HashableMixin):
    """
    Operation defines a generic operation that can be performed on a stream of data.
    It is a base class for all operations that can be performed on a collection of streams
    (including an empty collection).
    The operation is defined as a callable that takes a collection of streams as input
    and returns a new stream as output.
    Each invocation of the operation is assigned a unique ID. The corresponding invocation
    information is stored as Invocation object and attached to the output stream.
    """

    def __init__(self, label: Optional[str] = None, **kwargs) -> None:
        super().__init__(**kwargs)
        self._label = label

    def keys(self, *streams: "SyncStream") -> Tuple[List[str], List[str]]:
        """
        Returns the keys of the operation.
        The first list contains the keys of the tags, and the second list contains the keys of the packets.
        The keys are returned if it is feasible to do so, otherwise a tuple
        (None, None) is returned to signify that the keys are not known.
        """
        return None, None

    @property
    def label(self) -> str:
        """
        Overwrite this method to attain a custom label logic for the operation.
        """
        return self._label

    @label.setter
    def label(self, value: str) -> None:
        self._label = value

    def identity_structure(self, *streams: "SyncStream") -> Any:
        # Default implementation of identity_structure for the operation only
        # concerns the operation class and the streams if present. Subclasses of
        # Operations should override this method to provide a more meaningful
        # representation of the operation.
        return (self.__class__.__name__, streams)

    def __call__(self, *streams: "SyncStream") -> "SyncStream":
        # trigger call on source if passed as stream

        streams = [stream() if isinstance(stream, Source) else stream for stream in streams]
        output_stream = self.forward(*streams)
        # create an invocation instance
        invocation = Invocation(self, streams)
        # label the output_stream with the invocation information
        output_stream.invocation = invocation

        # delay import to avoid circular import
        from .tracker import Tracker

        # reg
        active_trackers = Tracker.get_active_trackers()
        for tracker in active_trackers:
            tracker.record(invocation)

        return output_stream

    def __repr__(self):
        return self.__class__.__name__

    def forward(self, *streams: "SyncStream") -> "SyncStream": ...


class Invocation(HashableMixin):
    """
    This class represents an invocation of an operation on a collection of streams.
    It contains the operation, the invocation ID, and the streams that were used
    in the invocation.
    The invocation ID is a unique identifier for the invocation and is used to
    track the invocation in the tracker.
    """

    def __init__(
        self,
        operation: Operation,
        streams: Collection["SyncStream"],
    ) -> None:
        self.operation = operation
        self.streams = streams

    def __hash__(self) -> int:
        return super().__hash__()

    def __repr__(self) -> str:
        return f"Invocation({self.operation}, ID:{hash(self)})"

    def keys(self) -> Tuple[Collection[str], Collection[str]]:
        return self.operation.keys(*self.streams)

    def identity_structure(self) -> int:
        # default implementation is streams order sensitive. If an operation does
        # not depend on the order of the streams, it should override this method
        return self.operation.identity_structure(*self.streams)

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Invocation):
            return False
        return hash(self) == hash(other)

    def __lt__(self, other: Any) -> bool:
        if not isinstance(other, Invocation):
            return NotImplemented

        if self.operation == other.operation:
            return hash(self) < hash(other)
        # otherwise, order by the operation
        return hash(self.operation) < hash(other.operation)


class Stream(HashableMixin):
    """
    A stream is a collection of tagged-packets that are generated by an operation.
    The stream is iterable and can be used to access the packets in the stream.

    A stream has propery `invocation` that is an instance of Invocation that generated the stream.
    This may be None if the stream is not generated by an operation.
    """

    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)
        self._invocation: Optional[Invocation] = None

    def identity_structure(self) -> Any:
        if self.invocation is not None:
            return self.invocation.identity_structure()
        return super().identity_structure()

    @property
    def invocation(self) -> Optional[Invocation]:
        return self._invocation

    @invocation.setter
    def invocation(self, value: Invocation) -> None:
        if not isinstance(value, Invocation):
            raise TypeError("invocation field must be an instance of Invocation")
        self._invocation = value

    def __iter__(self) -> Iterator[Tuple[Tag, Packet]]:
        raise NotImplementedError("Subclasses must implement __iter__ method")


class SyncStream(Stream):
    """
    A stream that will complete in a fixed amount of time. It is suitable for synchronous operations that
    will have to wait for the stream to finish before proceeding.
    """

    def content_hash(self) -> str:
        if self.invocation is not None:  # and hasattr(self.invocation, "invocation_id"):
            # use the invocation ID as the hash
            return self.invocation.content_hash()
        return super().content_hash()

    def keys(self) -> Tuple[Collection[str], Collection[str]]:
        """
        Returns the keys of the stream.
        The first list contains the keys of the tags, and the second list contains the keys of the packets.
        The keys are returned on based-effort basis, and this invocation may trigger the
        upstream computation of the stream.
        Furthermore, the keys are not guaranteed to be identical across all packets in the stream.
        This method is useful for inferring the keys of the stream without having to iterate
        over the entire stream.
        """
        if self.invocation is not None:
            # if the stream is generated by an operation, use the keys from the invocation
            tag_keys, packet_keys = self.invocation.keys()
            if tag_keys is not None and packet_keys is not None:
                return tag_keys, packet_keys
        # otherwise, use the keys from the first packet in the stream
        tag, packet = next(iter(self))
        return list(tag.keys()), list(packet.keys())

    def head(self, n: int = 5) -> None:
        """
        Print the first n elements of the stream.
        This method is useful for previewing the stream
        without having to iterate over the entire stream.
        If n is <= 0, the entire stream is printed.
        """
        for idx, (tag, packet) in enumerate(self):
            if n > 0 and idx >= n:
                break
            print(f"Tag: {tag}, Packet: {packet}")

    def __len__(self) -> int:
        """
        Returns the number of packets in the stream.
        Note that this method may trigger the upstream computation of the stream.
        This method is not guaranteed to be efficient and should be used with caution.
        """
        return sum(1 for _ in self)

    def __rshift__(self, transformer: Any) -> "SyncStream":
        """
        Returns a new stream that is the result of applying the mapping to the stream.
        The mapping is applied to each packet in the stream and the resulting packets
        are returned in a new stream.
        """
        from .mapper import MapPackets

        # TODO: extend to generic mapping
        if isinstance(transformer, dict):
            return MapPackets(transformer)(self)
        elif isinstance(transformer, Callable):
            return transformer(self)

    def __mul__(self, other: "SyncStream") -> "SyncStream":
        """
        Returns a new stream that is the result joining with the other stream
        """
        from .mapper import Join

        if not isinstance(other, SyncStream):
            raise TypeError("other must be a SyncStream")
        return Join()(self, other)


class Source(Operation, SyncStream):
    """
    A base class for all sources in the system. A source can be seen as a special
    type of Operation that takes no input and produces a stream of packets.
    For convenience, the source itself is also a stream and thus can be used
    as an input to other operations directly.
    """

    def __init__(self, label: Optional[str] = None, **kwargs) -> None:
        super().__init__(label=label, **kwargs)
        self._invocation = None

    def __iter__(self) -> Iterator[Tuple[Tag, Packet]]:
        yield from self()
